\section{Design}

\subsection{Decision - Red-Black Tree}

After examining the time complexity for various dictionary implementations, I decided a red-black tree was the most effective implementation for a general-purpose dictionary.

\\

\begin{table}[hp]
\centering
\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Implementation} & \textbf{Search} & \textbf{Insert} & \textbf{Delete} \\ \hline
AVL tree & O(lg n) & O(lg n) & O(lg n) \\ \hline
Red-black tree & O(lg n) & O(lg n) & O(lg n) \\ \hline
B-Tree & O(lg n) & O(lg n) & O(lg n) \\ \hline
Splay tree & (a) O(lg n) & (a) O(lg n) & (a) O(lg n) \\ \hline
Skip list & O(n) & O(n) & O(n) \\ \hline
Trie & O(m) & O(m) & O(m) \\ \hline
Stratified tree & O(lg lg N) & O(lg lg N) & O(lg lg N) \\ \hline
\end{tabular}
\\{\tiny{(n = number of elements in data structure, m = length of string, N = size of universe, (a) = amortised)}}\\
\caption{Considered data structures along with their worst-case time complexities.}
\end{table}

When deciding on the optimal data structure, I first ruled out splay tree and skip list, since the skip list worst case time is above the required O(lg n) and there are other data structures faster than the splay tree, where amortisation is not required. I then ruled out Trie, although it is extremely fast (independent of size of dictionary), since I aimed to implement a general-purpose dictionary and Trie only holds strings \parencite{trie}.

Initially I implemented basic functionality of a stratified tree \parencite{stratified}, also known as a van Emde Boas tree. The implementation had extremely fast lookup (\code{contains}, \code{max}, \code{min} O(1), and \code{successor}, \code{predecessor}, \code{add}, \code{delete} O(lg lg N)). However, my primary aim for this project was a \textit{general-purpose} and \textit{unbounded} dictionary. van Emde Boas trees are extremely fast, however the domain is bounded and each element requires an associated integer key. In the end I decided that van Emde Boas trees are too restrictive, and also more suited for a dictionary interface defined using keys and values (like \code{java.util.Map.put(K key, V value)}) and thus a more general purpose and unbounded but less efficient O(lg n) solution would be more appropriate for this situation.

Finally, I chose a red-black tree over an AVL tree after considering the usage of the dictionary described in the project: keeping track of users logged in to a web-service. I assume that in most cases, more users log on and off than search for each other, so \textit{insertions and deletions} are more common than \textit{lookups}. Since red-black trees have generally faster inserts and deletions \parencite{clrs} - whereas AVL trees are faster at searches - this would be the most appropriate choice.

The majority of my implementation is adapted from the pseudocode in the book 'Introduction to Algorithms: Third Edition' by T.H. Cormen, C.E. Stein, R.L. Rivest, and C. Stein.